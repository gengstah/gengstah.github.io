---
title: 'December 2025 Patch Tuesday'
date: 2025-12-10
permalink: /posts/2025/12/patch-tuesday/
tags:
  - windows
  - 1-day
  - patch diff
  - cldflt.sys
---

# CVE-2025-62221 - Windows Cloud Files Mini Filter Driver Elevation of Privilege Vulnerability
A Windows Cloud Files Mini Filter Driver (`cldflt.sys`) bug ([CVE-2025-62221](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-62221)) is being actively exploited this month and has been patched in this month's Patch Tuesday. In October, there was a TOCTOU bug ([CVE-2025-55680](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-55680)) patched in the same driver. This time around, the bug is a Use-after-Free (UaF). I looked at the patch made to the driver and shared my findings in this blog.

## Diff
The diff I generated using ghidriff is available at [cldflt.10.0.19041.6456.sys-cldflt.10.0.19045.6691.sys.md](https://diffpreview.github.io/?03457f16c27962139a7ce45baf4d76e8)

## Analysis
Looking at the diff, I found two places where a Use-after-Free can occur.

### `CldSyncDisconnectRoot`
The function returns `0` (success) even when the sync root lookup fails (`puVar2 == NULL`), the sync root is disconnected or the output parameter `param_3` is not set. However, looking at `CldiPortProcessServiceCommands` function which calls `CldSyncDisconnectRoot`, this behavior results to a call to `RtlDeleteElementGenericTableAvl` and a dangling pointer `a1 + 0x68`.

```c
InstanceContext = (unsigned int)CldSyncDisconnectRoot(v110, v99, &v107);
HsmDbgBreakOnStatus(InstanceContext);
if ( (int)InstanceContext >= 0 )
{
  FltAcquirePushLockExclusiveEx(a1 + 96, 0LL);
  RtlDeleteElementGenericTableAvl((PRTL_AVL_TABLE)(a1 + 0x68), &v106);
  FltReleasePushLockEx(a1 + 96, 0LL);
  if ( (*(_DWORD *)(a1 + 92))-- == 1 )
  {
    v101 = IoGetCurrentProcess();
    HsmOsClearProcessAsSyncProvider(v101);
    *(_QWORD *)(a1 + 80) = 0LL;
  }
  goto LABEL_374;
}
```

### `HsmiGrantLockRequest`
The function manages cross-references between two lists:
1. Temporary list (`local_48`): Created temporarily during function execution
2. Persistent list (at `param_1 + 0x40`): Lives beyond the function's lifetime

Around label `LAB_8` in the old code, nodes from the temporary list are linked into the persistent list:
```c
ppppuVar19[4] = ppppuVar4;  // persistent list node -> temp list node
ppppuVar4[5] = ppppuVar19;  // temp list node -> persistent list node
```

Then at cleanup (`LAB_3`), the temporary list nodes are freed:
```c
HsmiFreePropertyLock((longlong)ppppuVar1);  // FREE the temp node
```

The persistent list still has pointers (at offset `[4]`) pointing to the now-freed temporary list nodes. Any subsequent access through these pointers would trigger a use-after-free.


## Patch
### `CldSyncDisconnectRoot`
The patch makes sure the function returns proper error codes instead of always returning success.
```c
undefined4 CldSyncDisconnectRoot(longlong param_1, undefined8 param_2, 
                                 longlong param_3, undefined8 *param_4)
{
  longlong lVar1;
  undefined4 uVar2;
  longlong *plVar4;
  
  uVar2 = 0;                        // Success by default
  plVar4 = (longlong *)0x0;
  
  FltAcquirePushLockExclusiveEx(param_1 + 8, 0);
  lVar1 = RtlLookupElementGenericTableAvl(param_1 + 0x10);
  if (lVar1 != 0) {
    plVar4 = *(longlong **)(lVar1 + 8);
  }
  FltReleasePushLockEx(param_1 + 8);
  
  if (plVar4 == (longlong *)0x0) {
    uVar3 = 0xc000cf0b;             // Set error code
    uVar2 = 0xc000cf0b;
    [...snipped...]
  } else if (*plVar4 == param_3) {  // Validate handle matches
    CldSyncDisconnectRootByObject(plVar4, 0);
    *param_4 = plVar4;
  } else {
    uVar2 = 0xc000cf0b;             // Error if handle mismatch
    [...snipped...]
  }
  return uVar2;                     // Return actual status
}
```

### `HsmiGrantLockRequest`
The patch adds cleanup code before freeing temp nodes:
```c
ppppppuVar13 = (undefined8 ******)ppppppuVar1[5];  // Get linked persistent node
if (ppppppuVar13 != (undefined8 ******)0x0) {      // If cross-link exists
    ppppppuVar13[4] = (undefined8 *****)0x0;       // NULL out the back-pointer
}
ExFreePoolWithTag(ppppppuVar1,0x72507348);         // NOW it's safe to free
```
Additionally, the patch adds code to free the dynamically allocated owner arrays stored in temp nodes:
```c
if (*(int *)(local_48 + 4) != 0) {              // If array was allocated
    ExFreePoolWithTag(*pppppppuVar6,0x72507348); // Free it first
}
```

## Conclusion
This bug is interesting especially because it is actively exploited and I want to learn mini filter driver exploitation. I am doing some more analysis on the topic & I initially plan and started to write an in-depth analysis in this blog post but then decided it deserves a blog post on its own. Hopefully, I'll be able craft my own exploit in the coming weeks (months?), time willing (and skill willing). 

## References
- https://www.zerodayinitiative.com/blog/2025/12/9/the-december-2025-security-update-review
